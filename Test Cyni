import discord
from discord.ext import commands, tasks
from discord import app_commands
import sqlite3
import json
import requests
from typing import Optional
from typing import Optional
import discord
from discord import app_commands
import asyncio
from datetime import datetime
from discord.ext.commands import Bot
import time
from discord.ext import commands


bot = commands.Bot(command_prefix="!", intents=discord.Intents.all())


# Simple cooldown storage: {user_id: last_used_timestamp}
cooldowns = {}

# Cooldown time in seconds
COOLDOWN_SECONDS = 60



async def log_command_to_channel(bot: Bot, guild: discord.Guild, user: discord.User, command_str: str):
    c.execute("SELECT log_channel_id FROM config WHERE guild_id = ?", (guild.id,))
    row = c.fetchone()
    if not row or not row[0]:
        return  # No log channel set

    log_channel_id = row[0]
    log_channel = guild.get_channel(log_channel_id)
    if not log_channel:
        return

    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

    embed = discord.Embed(
        title="üì§ ER:LC Command Sent",
        color=discord.Color.green(),
        timestamp=datetime.utcnow()
    )
    embed.add_field(name="User", value=f"{user} (`{user.id}`)", inline=True)
    embed.add_field(name="Guild", value=f"{guild.name} (`{guild.id}`)", inline=True)
    embed.add_field(name="Command", value=f"```{command_str}```", inline=False)
    embed.set_footer(text=timestamp)

    try:
        await log_channel.send(embed=embed)
    except Exception as e:
        print(f"‚ùå Failed to send log message: {e}")


# === Configuration ===
REQUIRED_ROLE = "Admin"  # Change this to the role required for access

# === Discord Bot Setup ===
intents = discord.Intents.default()
intents.guilds = True
bot = commands.Bot(command_prefix="!", intents=intents)


# === In-Memory Cache (Optional Optimization) ===
message_pointers = {}

# === API Info ===
API_URL = "https://api.policeroleplay.community/v1/server/command"
API_HEADERS = {
    "server-key": "ljBJMCqzPJwiGPHthCzw-kNwJwWgQaqnbLXrMSHcbjRwqqcNSSozIoHqucoat",
    "Content-Type": "application/json"
}


conn = sqlite3.connect("automessage.db")
c = conn.cursor()

# Auto messages (many per guild)
c.execute('''
CREATE TABLE IF NOT EXISTS messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    guild_id INTEGER,
    message TEXT
)
''')

# Optional: Sent message logs
c.execute('''
CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    guild_id INTEGER,
    message TEXT,
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
''')
# Check if 'id' column exists
c.execute("PRAGMA table_info(messages)")
columns = [col[1] for col in c.fetchall()]
if 'id' not in columns:
    print("‚úÖ Adding 'id' column to 'messages' table...")

    # Create a new table with id
    c.execute('''
        CREATE TABLE IF NOT EXISTS messages_new (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            guild_id INTEGER,
            message TEXT
              # After successful POST to ER:LC API
              log_channel_id INTEGER
        )
    ''')

    # Copy existing data
    c.execute("INSERT INTO messages_new (guild_id, message) SELECT guild_id, message FROM messages")

    # Replace old table
    c.execute("DROP TABLE messages")
    c.execute("ALTER TABLE messages_new RENAME TO messages")

    conn.commit()
    print("‚úÖ Migration complete: 'id' column added.")
else:
    print("‚úÖ 'id' column already exists.")

conn = sqlite3.connect("automessage.db")
c = conn.cursor()


conn.commit()

print("‚úÖ Column 'api_key' added.")

# === Auto Message Loop ===
@tasks.loop(seconds=60)
async def auto_message_task():
    c.execute("SELECT * FROM config WHERE enabled = 1")
    configs = c.fetchall()
    for guild_id, enabled, interval, msg_type in configs:
        # Update pointer
        c.execute("SELECT message FROM messages WHERE guild_id = ?", (guild_id,))
        messages = [row[0] for row in c.fetchall()]
        if not messages:
            continue

        pointer = message_pointers.get(guild_id, 0)
        message = messages[pointer % len(messages)]
        message_pointers[guild_id] = (pointer + 1) % len(messages)

        payload = {
            "command": f"{msg_type} {message}"
        }

        try:
            response = requests.post(API_URL, headers=API_HEADERS, data=json.dumps(payload))
            print(f"[{guild_id}] Sent message: {payload['command']}")
        except Exception as e:
            print(f"[{guild_id}] Error: {e}")


# === Helper: Role Check ===
def has_required_role(interaction: discord.Interaction) -> bool:
    # Always allow the guild owner
    if interaction.user.id == interaction.guild.owner_id:
        return True

    # Allow users with the required role
    return any(role.name == REQUIRED_ROLE for role in interaction.user.roles)



# === View & Modals ===
class AutoMessageView(discord.ui.View):
    def __init__(self, guild_id: int):
        super().__init__(timeout=180)
        self.guild_id = guild_id

    @discord.ui.select(
        placeholder="Toggle Auto Messages",
        options=[
            discord.SelectOption(label="On", value="on"),
            discord.SelectOption(label="Off", value="off"),
        ]
    )
    async def toggle(self, interaction: discord.Interaction, select: discord.ui.Select):
        enabled = select.values[0] == "on"
        c.execute("INSERT OR IGNORE INTO config (guild_id) VALUES (?)", (self.guild_id,))
        c.execute("UPDATE config SET enabled = ? WHERE guild_id = ?", (enabled, self.guild_id))
        conn.commit()
        await interaction.response.send_message(f"‚úÖ Auto messages turned {'ON' if enabled else 'OFF'}", ephemeral=True)

    @discord.ui.button(label="Set Interval (sec)", style=discord.ButtonStyle.blurple)
    async def set_interval(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(IntervalModal(self.guild_id))

    @discord.ui.button(label="Set Message Type (:h or :m)", style=discord.ButtonStyle.gray)
    async def set_type(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(MessageTypeModal(self.guild_id))

    @discord.ui.button(label="Add New Message", style=discord.ButtonStyle.green)
    async def add_message(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(AddMessageModal(self.guild_id))


class IntervalModal(discord.ui.Modal, title="Set Message Interval (Seconds)"):
    def __init__(self, guild_id: int):
        super().__init__()
        self.guild_id = guild_id

    interval = discord.ui.TextInput(label="Interval (10s minimum)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        try:
            value = int(self.interval.value)
            if value < 10:
                await interaction.response.send_message("Interval must be at least 10 seconds.", ephemeral=True)
                return
            c.execute("UPDATE config SET interval = ? WHERE guild_id = ?", (value, self.guild_id))
            conn.commit()
            auto_message_task.change_interval(seconds=value)
            await interaction.response.send_message(f"‚è± Interval set to {value}s", ephemeral=True)
        except ValueError:
            await interaction.response.send_message("Invalid number.", ephemeral=True)


class MessageTypeModal(discord.ui.Modal, title="Set Message Type"):
    def __init__(self, guild_id: int):
        super().__init__()
        self.guild_id = guild_id

    msg_type = discord.ui.TextInput(label="Type (:h or :m)", required=True)

    async def on_submit(self, interaction: discord.Interaction):
        value = self.msg_type.value.strip()
        if value not in [":h", ":m"]:
            await interaction.response.send_message("Type must be `:h` or `:m`", ephemeral=True)
            return
        c.execute("UPDATE config SET message_type = ? WHERE guild_id = ?", (value, self.guild_id))
        conn.commit()
        await interaction.response.send_message(f"‚úÖ Message type set to `{value}`", ephemeral=True)


class AddMessageModal(discord.ui.Modal, title="Add Auto Message"):
    def __init__(self, guild_id: int):
        super().__init__()
        self.guild_id = guild_id

    message = discord.ui.TextInput(label="Message Text", style=discord.TextStyle.paragraph, required=True)

    async def on_submit(self, interaction: discord.Interaction):
        msg = self.message.value.strip()
        c.execute("INSERT INTO messages (guild_id, message) VALUES (?, ?)", (self.guild_id, msg))
        conn.commit()
        await interaction.response.send_message(f"‚úÖ Message added:\n```{msg}```", ephemeral=True)


# === Slash Commands ===
@bot.tree.command(name="setup_automessage", description="Configure ER:LC Auto Messaging (Admin Only)")
async def setup(interaction: discord.Interaction):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You do not have permission to use this.", ephemeral=True)
        return

    guild_id = interaction.guild_id
    c.execute("SELECT enabled, interval, message_type FROM config WHERE guild_id = ?", (guild_id,))
    row = c.fetchone()
    if not row:
        enabled, interval, msg_type = False, 60, ":h"
    else:
        enabled, interval, msg_type = row

    c.execute("SELECT message FROM messages WHERE guild_id = ?", (guild_id,))
    msgs = c.fetchall()

    embed = discord.Embed(
        title="üõ† ER:LC Auto Message Config",
        description="Customize auto-messaging for this server.",
        color=discord.Color.blurple()
    )
    embed.add_field(name="Status", value="‚úÖ Enabled" if enabled else "‚ùå Disabled", inline=True)
    embed.add_field(name="Interval", value=f"{interval}s", inline=True)
    embed.add_field(name="Message Type", value=msg_type, inline=True)
    embed.add_field(name="Messages", value="\n".join(f"‚Ä¢ {msg[0]}" for msg in msgs) or "*None*", inline=False)

    await interaction.response.send_message(embed=embed, view=AutoMessageView(guild_id), ephemeral=True)


# === Bot Ready ===
@bot.event
async def on_ready():
    await bot.tree.sync()
    auto_message_task.start()
    print(f"ü§ñ Logged in as {bot.user}")
# List messages with codes
@bot.tree.command(name="list_automessages", description="List all auto messages with their message codes (IDs)")
async def list_automessages(interaction: discord.Interaction):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You don‚Äôt have permission to use this.", ephemeral=True)
        return

    guild_id = interaction.guild_id

    c.execute("SELECT id, message FROM messages WHERE guild_id = ?", (guild_id,))
    rows = c.fetchall()

    if not rows:
        await interaction.response.send_message("‚ÑπÔ∏è No auto messages have been added yet for this server.", ephemeral=True)
        return

    # Format message list
    msg_list = "\n".join([f"`{msg_id}` ‚Ä¢ {msg[:100]}" for msg_id, msg in rows])  # Truncate long messages for display

    embed = discord.Embed(
        title="üìú Auto Messages List",
        description="Below are the messages currently set up for rotation:\n\n" + msg_list,
        color=discord.Color.blurple()
    )
    embed.set_footer(text="Use the ID to edit or delete a message with /edit_automessage or /remove_automessage")

    await interaction.response.send_message(embed=embed, ephemeral=True)



# Remove message by code
@bot.tree.command(name="modify_automessage", description="Edit or delete an auto message by its ID")
@app_commands.describe(
    code="The auto message ID shown in /list_automessages",
    new_message="If set, replaces the message content",
    delete_message="Set to True to delete the message instead"
)
async def modify_automessage(
    interaction: discord.Interaction,
    code: int,
    new_message: Optional[str] = None,
    delete_message: Optional[bool] = False
):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You don‚Äôt have permission.", ephemeral=True)
        return

    guild_id = interaction.guild_id

    # Delete mode
    if delete_message:
        c.execute("DELETE FROM messages WHERE id = ? AND guild_id = ?", (code, guild_id))
        if c.rowcount == 0:
            await interaction.response.send_message("‚ö†Ô∏è No message found with that ID.", ephemeral=True)
        else:
            conn.commit()
            await interaction.response.send_message(f"‚úÖ Message `{code}` has been deleted.", ephemeral=True)
        return

    # Edit mode
    if new_message:
        new_message = new_message.strip()
        if len(new_message) == 0:
            await interaction.response.send_message("‚ö†Ô∏è Message cannot be empty.", ephemeral=True)
            return

        c.execute("UPDATE messages SET message = ? WHERE id = ? AND guild_id = ?", (new_message, code, guild_id))
        if c.rowcount == 0:
            await interaction.response.send_message("‚ö†Ô∏è No message found with that ID.", ephemeral=True)
        else:
            conn.commit()
            await interaction.response.send_message(f"‚úÖ Message `{code}` has been updated to:\n```{new_message}```", ephemeral=True)
        return

    # If neither provided
    await interaction.response.send_message("‚ö†Ô∏è You must provide either `new_message` or `delete_message=True`.", ephemeral=True)

@bot.tree.command(name="set_api_key", description="Set your ER:LC API key for auto messages")
@app_commands.describe(api_key="Your server's ER:LC API key")
async def set_api_key(interaction: discord.Interaction, api_key: str):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You don't have permission to use this.", ephemeral=True)
        return

    c.execute("INSERT OR IGNORE INTO config (guild_id) VALUES (?)", (interaction.guild_id,))
    c.execute("UPDATE config SET api_key = ? WHERE guild_id = ?", (api_key.strip(), interaction.guild_id))
    conn.commit()
    await interaction.response.send_message("‚úÖ API key has been saved securely for this server.", ephemeral=True)
@tasks.loop(seconds=60)
async def auto_message_task():
    c.execute("SELECT guild_id, interval, message_type, api_key FROM config WHERE enabled = 1")
    configs = c.fetchall()

    for guild_id, interval, msg_type, api_key in configs:
        if not api_key:
            print(f"[{guild_id}] Skipping: No API key set.")
            continue

        c.execute("SELECT message FROM messages WHERE guild_id = ?", (guild_id,))
        messages = [row[0] for row in c.fetchall()]
        if not messages:
            continue

        pointer = message_pointers.get(guild_id, 0)
        message = messages[pointer % len(messages)]
        message_pointers[guild_id] = (pointer + 1) % len(messages)

        payload = {"command": f"{msg_type} {message}"}
        headers = {
            "server-key": api_key,
            "Content-Type": "application/json"
        }

        try:
            response = requests.post(API_URL, headers=headers, data=json.dumps(payload))
            print(f"[{guild_id}] Sent: {payload['command']} | Status: {response.status_code}")
        except Exception as e:
            print(f"[{guild_id}] Error sending message: {e}")

import time

# Simple cooldown storage: {user_id: last_used_timestamp}


# Cooldown storage
cooldowns = {}
COOLDOWN_SECONDS = 60

@bot.tree.command(name="send_command", description="Send a command to your ER:LC server via the API")
@app_commands.describe(command="The ER:LC command to send (e.g., !h Hello or :m Announcement)")
async def send_command(interaction: discord.Interaction, command: str):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You don't have permission to use this command.", ephemeral=True)
        return

    cmd_lower = command.lower()

    # ‚úÖ Enforce allowed prefixes
    if not (command.startswith(":") or command.startswith("!")):
        await interaction.response.send_message("‚ùå Command must start with `:` or `!`.", ephemeral=True)
        return

    # ‚ùå Block commands with "all"
    if "all" in cmd_lower:
        await interaction.response.send_message("üö´ Commands containing '`all`' are not allowed for safety reasons.", ephemeral=True)
        return

    # ‚è≥ Cooldown check for dangerous keywords
    cooldown_keywords = ["ban", "kick", "jail"]
    if any(keyword in cmd_lower for keyword in cooldown_keywords):
        user_id = interaction.user.id
        now = time.time()
        last_used = cooldowns.get(user_id, 0)
        elapsed = now - last_used

        if elapsed < COOLDOWN_SECONDS:
            remaining = int(COOLDOWN_SECONDS - elapsed)
            await interaction.response.send_message(
                f"‚è≥ You must wait `{remaining}s` before using commands containing `ban`, `kick`, or `jail`.",
                ephemeral=True
            )
            return

        cooldowns[user_id] = now  # Start cooldown

    # üîê Get the API key from your DB
    c.execute("SELECT api_key FROM config WHERE guild_id = ?", (interaction.guild_id,))
    row = c.fetchone()

    if not row or not row[0]:
        await interaction.response.send_message("‚ùå API key not set for this server. Use `/set_api_key` first.", ephemeral=True)
        return

    api_key = row[0]

    # üì§ Send command to ER:LC API
    try:
        response = requests.post(
            "https://api.policeroleplay.community/v1/server/command",
            headers={
                "server-key": api_key,
                "Content-Type": "application/json"
            },
            data=json.dumps({"command": command})
        )

        if response.status_code == 200:
            await interaction.response.send_message(f"‚úÖ Command sent:\n```{command}```", ephemeral=True)

            # Optional: Log the command
            asyncio.create_task(log_command_to_channel(bot, interaction.guild, interaction.user, command))

        else:
            await interaction.response.send_message(
                f"‚ùå Failed to send command. Status: `{response.status_code}`\n```{response.text}```",
                ephemeral=True
            )

    except Exception as e:
        await interaction.response.send_message(f"‚ùå Error sending command: `{e}`", ephemeral=True)

    guild_id = interaction.guild_id

    # Get stored API key
    c.execute("SELECT api_key FROM config WHERE guild_id = ?", (guild_id,))
    row = c.fetchone()

    if not row or not row[0]:
        await interaction.response.send_message("‚ùå No API key is set for this server. Use `/set_api_key` first.", ephemeral=True)
        return

    api_key = row[0]
    payload = {"command": command}
    headers = {
        "server-key": api_key,
        "Content-Type": "application/json"
    }

    try:
        response = requests.post(
            "https://api.policeroleplay.community/v1/server/command",
            headers=headers,
            data=json.dumps(payload)
        )

        if response.status_code == 200:
            await interaction.response.send_message(f"‚úÖ Command sent:\n```{command}```", ephemeral=True)
        else:
            await interaction.response.send_message(
                f"‚ùå Failed to send command. Status code: {response.status_code}\nDetails: {response.text}",
                ephemeral=True
            )
    except Exception as e:
        await interaction.response.send_message(f"‚ùå An error occurred: `{e}`", ephemeral=True)
def has_required_role(interaction: discord.Interaction) -> bool:
    # Allow the server owner to bypass role checks
    if interaction.user.id == interaction.guild.owner_id:
        return True

@bot.tree.command(name="set_log_channel", description="Set the channel where sent ER:LC commands will be logged")
@app_commands.describe(channel="Select the log channel")
async def set_log_channel(interaction: discord.Interaction, channel: discord.TextChannel):
    if not has_required_role(interaction):
        await interaction.response.send_message("‚õî You don‚Äôt have permission to use this.", ephemeral=True)
        return

    c.execute("INSERT OR IGNORE INTO config (guild_id) VALUES (?)", (interaction.guild_id,))
    c.execute("UPDATE config SET log_channel_id = ? WHERE guild_id = ?", (channel.id, interaction.guild_id))
    conn.commit()

    await interaction.response.send_message(f"‚úÖ Log channel set to {channel.mention}.", ephemeral=True)
# Inside your command function or auto_message_task, after sending
def log_command_to_channel(guild: discord.Guild, command_str: str):
    c.execute("SELECT log_channel_id FROM config WHERE guild_id = ?", (guild.id,))
    row = c.fetchone()
    if not row or not row[0]:
        return  # No log channel set

    log_channel_id = row[0]
    log_channel = guild.get_channel(log_channel_id)
    if log_channel:
        try:
            asyncio.create_task(log_channel.send(f"üì§ **Command sent:** `{command_str}`"))
        except Exception as e:
            print(f"‚ùå Failed to log to channel: {e}")

# After successful POST to ER:LC API

@bot.event
async def on_ready():
    try:
        synced = await bot.tree.sync()
        print(f"‚úÖ Synced {len(synced)} slash commands.")
    except Exception as e:
        print(f"‚ùå Failed to sync commands: {e}")

    print(f"‚úÖ Logged in as {bot.user} (ID: {bot.user.id})")


bot.run("MTI2NzAyMDA2MTc4NTQ1NjcxMQ.Gf_dPP.G7yEWmckZ7La6ZVPcjkuC2KMCcwF9lcy1-t4_8")